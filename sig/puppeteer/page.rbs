# Generated from lib/puppeteer/page.rb with RBS::Inline

class Puppeteer::Page
  include Puppeteer::DebugPrint

  include Puppeteer::EventCallbackable

  include Puppeteer::IfPresent

  # @rbs client: Puppeteer::CDPSession -- CDP session for the page
  # @rbs target: Puppeteer::Target -- Target associated with the page
  # @rbs ignore_https_errors: bool -- Ignore HTTPS errors
  # @rbs default_viewport: Puppeteer::Viewport? -- Default viewport for new pages
  # @rbs network_enabled: bool -- Whether network events are enabled
  # @rbs return: Puppeteer::Page -- Created page instance
  def self.create: (Puppeteer::CDPSession client, Puppeteer::Target target, bool ignore_https_errors, Puppeteer::Viewport? default_viewport, ?network_enabled: bool) -> Puppeteer::Page

  # @rbs client: Puppeteer::CDPSession -- CDP session for the page
  # @rbs target: Puppeteer::Target -- Target associated with the page
  # @rbs ignore_https_errors: bool -- Ignore HTTPS errors
  # @rbs network_enabled: bool -- Whether network events are enabled
  # @rbs return: void -- No return value
  def initialize: (Puppeteer::CDPSession client, Puppeteer::Target target, bool ignore_https_errors, ?network_enabled: bool) -> void

  private def handle_detached_from_target: (untyped target) -> untyped

  private def handle_attached_to_session: (untyped session) -> untyped

  private def handle_attached_to_target: (untyped target) -> untyped

  # @rbs return: Array[untyped] -- Initialization results
  def init: () -> Array[untyped]

  # @rbs return: bool -- Whether drag interception is enabled
  def drag_interception_enabled?: () -> bool

  # @rbs event_name: (String | Symbol) -- Page event name
  # @rbs &block: ^(untyped) -> void -- Event handler
  # @rbs return: String -- Listener ID
  def on: (String | Symbol event_name) ?{ (?) -> untyped } -> String

  # @rbs event_name: (String | Symbol) -- Page event name
  # @rbs &block: ^(untyped) -> void -- Event handler
  # @rbs return: String -- Listener ID
  def once: (String | Symbol event_name) ?{ (?) -> untyped } -> String

  # @rbs event_name_or_id: (String | Symbol) -- Page event name or listener ID
  # @rbs listener: Proc? -- Event handler to remove
  # @rbs return: void -- No return value
  def off: (String | Symbol event_name_or_id, ?Proc? listener) ?{ (?) -> untyped } -> void

  # @rbs event: Hash[String, untyped] -- File chooser event payload
  # @rbs return: void -- No return value
  def handle_file_chooser: (Hash[String, untyped] event) -> void

  # @rbs timeout: Numeric? -- Timeout in milliseconds
  # @rbs return: Puppeteer::FileChooser -- File chooser handle
  def wait_for_file_chooser: (?timeout: Numeric?) -> Puppeteer::FileChooser

  # @rbs geolocation: Puppeteer::Geolocation -- Geolocation override
  # @rbs return: void -- No return value
  def geolocation=: (Puppeteer::Geolocation geolocation) -> void

  attr_reader javascript_enabled: untyped

  attr_reader service_worker_bypassed: untyped

  attr_reader target: untyped

  attr_reader client: untyped

  # @rbs return: String -- Tab target id
  def _tab_id: () -> String

  # @rbs other: Object -- Other object to compare
  # @rbs return: bool -- Equality result
  def ==: (Object other) -> bool

  # @rbs return: Puppeteer::Browser -- Owning browser
  def browser: () -> Puppeteer::Browser

  # @rbs return: Puppeteer::BrowserContext -- Owning browser context
  def browser_context: () -> Puppeteer::BrowserContext

  class TargetCrashedError < Puppeteer::Error
  end

  private def handle_target_crashed: () -> untyped

  private def handle_log_entry_added: (untyped event) -> untyped

  # @rbs return: Puppeteer::Frame -- Main frame
  def main_frame: () -> Puppeteer::Frame

  attr_reader touchscreen: untyped

  attr_reader coverage: untyped

  attr_reader tracing: untyped

  attr_reader accessibility: untyped

  # @rbs block: Proc? -- Optional block for instance_eval
  # @rbs return: Puppeteer::Keyboard -- Keyboard instance
  def keyboard: () ?{ (?) -> untyped } -> Puppeteer::Keyboard

  # @rbs return: Array[Puppeteer::Frame] -- All frames
  def frames: () -> Array[Puppeteer::Frame]

  # @rbs return: Array[untyped] -- Active web workers
  def workers: () -> Array[untyped]

  # @rbs value: bool -- Enable request interception
  # @rbs return: void -- No return value
  def request_interception=: (bool value) -> void

  # @rbs enabled: bool -- Enable drag interception
  # @rbs return: void -- No return value
  def drag_interception_enabled=: (bool enabled) -> void

  # @rbs bypass: bool -- Bypass service workers
  # @rbs return: void -- No return value
  def service_worker_bypassed=: (bool bypass) -> void

  # @rbs enabled: bool -- Enable offline mode
  # @rbs return: void -- No return value
  def offline_mode=: (bool enabled) -> void

  # @rbs network_condition: Puppeteer::NetworkCondition? -- Network condition override
  # @rbs return: void -- No return value
  def emulate_network_conditions: (Puppeteer::NetworkCondition? network_condition) -> void

  # @rbs timeout: Numeric? -- Default navigation timeout in milliseconds
  # @rbs return: void -- No return value
  def default_navigation_timeout=: (Numeric? timeout) -> void

  # @rbs timeout: Numeric? -- Default timeout in milliseconds
  # @rbs return: void -- No return value
  def default_timeout=: (Numeric? timeout) -> void

  # @rbs return: Numeric -- Default timeout in milliseconds
  def default_timeout: () -> Numeric

  # @rbs selector_or_function: String -- Selector or JS function
  # @rbs return: Puppeteer::Locator -- Locator for selector or function
  def locator: (String selector_or_function) -> Puppeteer::Locator

  # `$()` in JavaScript.
  # @rbs selector: String -- CSS selector
  # @rbs return: Puppeteer::ElementHandle? -- Matching element or nil
  def query_selector: (String selector) -> Puppeteer::ElementHandle?

  # `$$()` in JavaScript.
  # @rbs selector: String -- CSS selector
  # @rbs isolate: bool? -- Use isolated world for queries
  # @rbs return: Array[Puppeteer::ElementHandle] -- Matching elements
  def query_selector_all: (String selector, ?isolate: bool?) -> Array[Puppeteer::ElementHandle]

  # @rbs page_function: String -- Function or expression to evaluate
  # @rbs args: Array[untyped] -- Arguments for evaluation
  # @rbs return: Puppeteer::JSHandle -- Handle to evaluation result
  def evaluate_handle: (String page_function, *untyped args) -> Puppeteer::JSHandle

  # @rbs prototype_handle: Puppeteer::JSHandle -- Prototype handle
  # @rbs return: Puppeteer::JSHandle -- Handle to query result
  def query_objects: (Puppeteer::JSHandle prototype_handle) -> Puppeteer::JSHandle

  # `$eval()` in JavaScript.
  # @rbs selector: String -- CSS selector
  # @rbs page_function: String -- Function or expression to evaluate
  # @rbs args: Array[untyped] -- Arguments for evaluation
  # @rbs return: untyped -- Evaluation result
  def eval_on_selector: (String selector, String page_function, *untyped args) -> untyped

  # `$$eval()` in JavaScript.
  # @rbs selector: String -- CSS selector
  # @rbs page_function: String -- Function or expression to evaluate
  # @rbs args: Array[untyped] -- Arguments for evaluation
  # @rbs return: untyped -- Evaluation result
  def eval_on_selector_all: (String selector, String page_function, *untyped args) -> untyped

  # `$x()` in JavaScript. $ is not allowed to use as a method name in Ruby.
  # @rbs expression: String -- XPath expression
  # @rbs return: Array[Puppeteer::ElementHandle] -- Matching elements
  def Sx: (String expression) -> Array[Puppeteer::ElementHandle]

  # @rbs urls: Array[String] -- URLs to fetch cookies for
  # @rbs return: Array[Hash[String, untyped]] -- Cookies list
  def cookies: (*untyped urls) -> Array[Hash[String, untyped]]

  # check if each cookie element has required fields ('name' and 'value')
  private def assert_cookie_params: (untyped cookies, requires: untyped) -> untyped

  private def convert_same_site_for_cdp: (untyped same_site) -> untyped

  # @rbs cookies: Array[Hash[Symbol | String, untyped]] -- cookies parameter
  # @rbs return: void -- No return value
  def delete_cookie: (*untyped cookies) -> void

  # @rbs cookies: Array[Hash[Symbol | String, untyped]] -- cookies parameter
  # @rbs return: void -- No return value
  def set_cookie: (*untyped cookies) -> void

  # @rbs url: String? -- Script URL
  # @rbs path: String? -- Path to script file
  # @rbs content: String? -- Script contents
  # @rbs type: String? -- Script type
  # @rbs id: String? -- Script element ID
  # @rbs return: Puppeteer::ElementHandle -- Script element handle
  def add_script_tag: (?url: String?, ?path: String?, ?content: String?, ?type: String?, ?id: String?) -> Puppeteer::ElementHandle

  # @rbs url: String? -- Stylesheet URL
  # @rbs path: String? -- Path to stylesheet file
  # @rbs content: String? -- Stylesheet contents
  # @rbs return: Puppeteer::ElementHandle -- Style element handle
  def add_style_tag: (?url: String?, ?path: String?, ?content: String?) -> Puppeteer::ElementHandle

  # @rbs name: String -- Binding name
  # @rbs puppeteer_function: Proc -- Ruby callback
  # @rbs return: void -- No return value
  def expose_function: (String name, Proc puppeteer_function) -> void

  # @rbs name: String -- Binding name
  # @rbs return: void -- No return value
  def remove_exposed_function: (String name) -> void

  # @rbs username: String? -- HTTP basic auth username
  # @rbs password: String? -- HTTP basic auth password
  # @rbs return: void -- No return value
  def authenticate: (?username: String?, ?password: String?) -> void

  # @rbs headers: Hash[String, String] -- Extra HTTP headers
  # @rbs return: void -- No return value
  def extra_http_headers=: (Hash[String, String] headers) -> void

  # @rbs user_agent: String -- User agent string
  # @rbs user_agent_metadata: Hash[String, untyped]? -- User agent metadata
  # @rbs return: void -- No return value
  def set_user_agent: (String user_agent, ?Hash[String, untyped]? user_agent_metadata) -> void

  # @rbs return: Puppeteer::Page::Metrics -- Page metrics
  def metrics: () -> Puppeteer::Page::Metrics

  # @rbs path: String -- Output path for the heap snapshot
  # @rbs return: void -- No return value
  def capture_heap_snapshot: (path: String) -> void

  class PageError < Puppeteer::Error
  end

  private def handle_exception: (untyped exception_details) -> untyped

  private def handle_console_api: (untyped event) -> untyped

  # @rbs event: Hash[String, untyped] -- Binding called payload
  # @rbs return: void -- No return value
  def handle_binding_called: (Hash[String, untyped] event) -> void

  private def add_console_message: (untyped type, untyped args, untyped stack_trace) -> untyped

  private def handle_dialog_opening: (untyped event) -> untyped

  private def set_transparent_background_color: () ?{ (?) -> untyped } -> untyped

  private def reset_default_background_color: () ?{ (?) -> untyped } -> untyped

  # @rbs return: String? -- Page URL
  def url: () -> String?

  # @rbs return: String -- Page HTML content
  def content: () -> String

  # @rbs html: String -- HTML content
  # @rbs timeout: Numeric? -- Navigation timeout in milliseconds
  # @rbs wait_until: String | Array[String] | nil -- Lifecycle events to wait for
  # @rbs return: void -- No return value
  def set_content: (String html, ?timeout: Numeric?, ?wait_until: String | Array[String] | nil) -> void

  # @rbs html: String -- HTML content
  # @rbs return: void -- No return value
  def content=: (String html) -> void

  # @rbs url: String -- URL to navigate
  # @rbs referer: String? -- Referer header value
  # @rbs referer: String? -- Referer header value
  # @rbs referrer_policy: String? -- Referrer policy
  # @rbs timeout: Numeric? -- Navigation timeout in milliseconds
  # @rbs wait_until: String | Array[String] | nil -- Lifecycle events to wait for
  # @rbs return: Puppeteer::HTTPResponse? -- Navigation response
  def goto: (String url, ?referer: String?, ?referrer_policy: String?, ?timeout: Numeric?, ?wait_until: String | Array[String] | nil) -> Puppeteer::HTTPResponse?

  # @rbs timeout: Numeric? -- Navigation timeout in milliseconds
  # @rbs wait_until: String | Array[String] | nil -- Lifecycle events to wait for
  # @rbs ignore_cache: bool? -- Skip cache when reloading
  # @rbs return: Puppeteer::HTTPResponse? -- Navigation response
  def reload: (?timeout: Numeric?, ?wait_until: String | Array[String] | nil, ?ignore_cache: bool?) -> Puppeteer::HTTPResponse?

  # @rbs timeout: Numeric? -- Navigation timeout in milliseconds
  # @rbs wait_until: String | Array[String] | nil -- Lifecycle events to wait for
  # @rbs ignore_same_document_navigation: bool -- Ignore same-document navigation
  # @rbs return: Puppeteer::HTTPResponse? -- Navigation response
  def wait_for_navigation: (?timeout: Numeric?, ?wait_until: String | Array[String] | nil, ?ignore_same_document_navigation: bool) -> Puppeteer::HTTPResponse?

  private def wait_for_network_manager_event: (untyped event_name, predicate: untyped, timeout: untyped) -> untyped

  private def wait_for_frame_manager_event: (*untyped event_names, predicate: untyped, timeout: untyped) -> untyped

  private def session_close_promise: () -> untyped

  # @rbs url: String? -- URL to match
  # @rbs predicate: Proc? -- Predicate to match
  # @rbs timeout: Numeric? -- Timeout in milliseconds
  # @rbs return: Puppeteer::HTTPRequest -- Matching request
  def wait_for_request: (?url: String?, ?predicate: Proc?, ?timeout: Numeric?) -> Puppeteer::HTTPRequest

  # @rbs url: String? -- URL to match
  # @rbs predicate: Proc? -- Predicate to match
  # @rbs timeout: Numeric? -- Timeout in milliseconds
  # @rbs return: Puppeteer::HTTPResponse -- Matching response
  def wait_for_response: (?url: String?, ?predicate: Proc?, ?timeout: Numeric?) -> Puppeteer::HTTPResponse

  # @rbs idle_time: Numeric -- Idle time to wait for in milliseconds
  # @rbs timeout: Numeric? -- Timeout in milliseconds
  # @rbs concurrency: Integer -- Allowed number of concurrent requests
  # @rbs return: void -- No return value
  def wait_for_network_idle: (?idle_time: Numeric, ?timeout: Numeric?, ?concurrency: Integer) -> void

  # @rbs url: String? -- URL to match
  # @rbs predicate: Proc? -- Predicate to match
  # @rbs timeout: Numeric? -- Timeout in milliseconds
  # @rbs return: Puppeteer::Frame -- Matching frame
  def wait_for_frame: (?url: String?, ?predicate: Proc?, ?timeout: Numeric?) -> Puppeteer::Frame

  # @rbs timeout: Numeric? -- Navigation timeout in milliseconds
  # @rbs wait_until: String | Array[String] | nil -- Lifecycle events to wait for
  # @rbs return: Puppeteer::HTTPResponse? -- Navigation response
  def go_back: (?timeout: Numeric?, ?wait_until: String | Array[String] | nil) -> Puppeteer::HTTPResponse?

  # @rbs timeout: Numeric? -- Navigation timeout in milliseconds
  # @rbs wait_until: String | Array[String] | nil -- Lifecycle events to wait for
  # @rbs return: Puppeteer::HTTPResponse? -- Navigation response
  def go_forward: (?timeout: Numeric?, ?wait_until: String | Array[String] | nil) -> Puppeteer::HTTPResponse?

  private def go: (untyped delta, ?timeout: untyped, ?wait_until: untyped) -> untyped

  # Brings page to front (activates tab).
  # @rbs return: void -- No return value
  def bring_to_front: () -> void

  # @rbs device: Puppeteer::Device -- Device descriptor
  # @rbs return: void -- No return value
  def emulate: (Puppeteer::Device device) -> void

  # @rbs enabled: bool -- Enable JavaScript
  # @rbs return: void -- No return value
  def javascript_enabled=: (bool enabled) -> void

  # @rbs enabled: bool -- Enable bypassing CSP
  # @rbs return: void -- No return value
  def bypass_csp=: (bool enabled) -> void

  # @rbs media_type: (String | Symbol)? -- Media type override
  # @rbs return: void -- No return value
  def emulate_media_type: ((String | Symbol)? media_type) -> void

  # @rbs factor: Numeric? -- CPU throttling rate
  # @rbs return: void -- No return value
  def emulate_cpu_throttling: (Numeric? factor) -> void

  # @rbs features: Array[Hash[Symbol, untyped]]? -- Media feature overrides
  # @rbs return: void -- No return value
  def emulate_media_features: (Array[Hash[Symbol, untyped]]? features) -> void

  # @rbs timezone_id: String? -- Timezone ID
  # @rbs return: void -- No return value
  def emulate_timezone: (String? timezone_id) -> void

  VISION_DEFICIENCY_TYPES: untyped

  # @rbs vision_deficiency_type: String? -- Vision deficiency type
  # @rbs return: void -- No return value
  def emulate_vision_deficiency: (String? vision_deficiency_type) -> void

  # @rbs is_user_active: bool? -- User activity override
  # @rbs is_screen_unlocked: bool? -- Screen unlocked override
  # @rbs return: void -- No return value
  def emulate_idle_state: (?is_user_active: bool?, ?is_screen_unlocked: bool?) -> void

  # @rbs viewport: Puppeteer::Viewport? -- Viewport settings
  # @rbs return: void -- No return value
  def viewport=: (Puppeteer::Viewport? viewport) -> void

  attr_reader viewport: untyped

  # @rbs page_function: String -- page_function parameter
  # @rbs args: Array[untyped] -- args parameter
  # @rbs return: untyped -- Result
  def evaluate: (String page_function, *untyped args) -> untyped

  class JavaScriptFunction
    # @rbs expression: String -- Function expression
    # @rbs args: Array[untyped] -- Arguments for evaluation
    # @rbs return: void -- No return value
    def initialize: (String expression, Array[untyped] args) -> void

    # @rbs return: String -- Generated source
    def source: () -> String

    private def arguments: () -> untyped
  end

  class JavaScriptExpression
    # @rbs expression: String -- Expression to evaluate
    # @rbs return: void -- No return value
    def initialize: (String expression) -> void

    # @rbs return: String -- Generated source
    def source: () -> String
  end

  # @rbs page_function: String -- page_function parameter
  # @rbs args: Array[untyped] -- args parameter
  # @rbs return: Hash[String, untyped] -- CDP response
  def evaluate_on_new_document: (String page_function, *untyped args) -> Hash[String, untyped]

  # @rbs identifier: String -- Script identifier to remove
  # @rbs return: void
  def remove_script_to_evaluate_on_new_document: (String identifier) -> void

  # @rbs enabled: bool -- Enable cache usage
  def cache_enabled=: (bool enabled) -> untyped

  # @rbs return: String -- Page title
  def title: () -> String

  # @rbs type: String? -- Image format
  # @rbs path: String? -- File path to save
  # @rbs full_page: bool? -- Capture full page
  # @rbs clip: Hash[Symbol, Numeric]? -- Clip rectangle
  # @rbs quality: Integer? -- JPEG quality
  # @rbs omit_background: bool? -- Omit background for PNG
  # @rbs encoding: String? -- Encoding (base64 or binary)
  # @rbs capture_beyond_viewport: bool? -- Capture beyond viewport
  # @rbs from_surface: bool? -- Capture from surface
  # @rbs return: String -- Screenshot data
  def screenshot: (?type: String?, ?path: String?, ?full_page: bool?, ?clip: Hash[Symbol, Numeric]?, ?quality: Integer?, ?omit_background: bool?, ?encoding: String?, ?capture_beyond_viewport: bool?, ?from_surface: bool?) -> String

  private def screenshot_task: (untyped format, untyped screenshot_options) -> untyped

  class PrintToPdfIsNotImplementedError < Puppeteer::Error
    # @rbs return: void -- No return value
    def initialize: () -> void
  end

  # @rbs options: Hash[Symbol, untyped] -- PDF options
  # @rbs return: Enumerable[String] -- PDF data chunks
  def create_pdf_stream: (?Hash[Symbol, untyped] options) -> Enumerable[String]

  # @rbs options: Hash[Symbol, untyped] -- PDF options
  # @rbs return: String -- PDF data
  def pdf: (?Hash[Symbol, untyped] options) -> String

  # @rbs run_before_unload: bool -- Whether to run beforeunload handlers
  # @rbs return: void -- No return value
  def close: (?run_before_unload: bool) -> void

  # @rbs return: bool -- Whether the page is closed
  def closed?: () -> bool

  attr_reader mouse: untyped

  # @rbs selector: String -- CSS selector
  # @rbs delay: Numeric? -- Delay between down and up (ms)
  # @rbs button: String? -- Mouse button
  # @rbs click_count: Integer? -- Deprecated: use count (click_count only sets clickCount)
  # @rbs count: Integer? -- Number of clicks to perform
  # @rbs return: void -- No return value
  def click: (String selector, ?delay: Numeric?, ?button: String?, ?click_count: Integer?, ?count: Integer?) -> void

  # @rbs selector: String -- CSS selector
  # @rbs return: void -- No return value
  def focus: (String selector) -> void

  # @rbs selector: String -- CSS selector
  # @rbs return: void -- No return value
  def hover: (String selector) -> void

  # @rbs selector: String -- CSS selector
  # @rbs values: Array[String] -- Option values to select
  # @rbs return: Array[String] -- Selected values
  def select: (String selector, *untyped values) -> Array[String]

  # @rbs selector: String? -- CSS selector
  # @rbs block: Proc? -- Optional block for Object#tap usage
  # @rbs return: Puppeteer::Page | nil -- Page instance or nil
  def tap: (?selector: String?) ?{ (?) -> untyped } -> (Puppeteer::Page | nil)

  # @rbs selector: String -- CSS selector
  # @rbs text: String -- Text to type
  # @rbs delay: Numeric? -- Delay between key presses (ms)
  # @rbs return: void -- No return value
  def type_text: (String selector, String text, ?delay: Numeric?) -> void

  # @rbs selector: String -- CSS selector
  # @rbs visible: bool? -- Wait for element to be visible
  # @rbs hidden: bool? -- Wait for element to be hidden
  # @rbs timeout: Numeric? -- Maximum wait time in milliseconds
  # @rbs return: Puppeteer::ElementHandle? -- Matching element or nil
  def wait_for_selector: (String selector, ?visible: bool?, ?hidden: bool?, ?timeout: Numeric?) -> Puppeteer::ElementHandle?

  # @rbs milliseconds: Numeric -- Time to wait in milliseconds
  # @rbs return: void -- No return value
  def wait_for_timeout: (Numeric milliseconds) -> void

  # @rbs xpath: String -- XPath expression
  # @rbs visible: bool? -- Wait for element to be visible
  # @rbs hidden: bool? -- Wait for element to be hidden
  # @rbs timeout: Numeric? -- Maximum wait time in milliseconds
  # @rbs return: Puppeteer::ElementHandle? -- Matching element or nil
  def wait_for_xpath: (String xpath, ?visible: bool?, ?hidden: bool?, ?timeout: Numeric?) -> Puppeteer::ElementHandle?

  # @rbs page_function: String -- Function or expression to evaluate
  # @rbs args: Array[untyped] -- Arguments for evaluation
  # @rbs polling: String | Numeric | nil -- Polling strategy
  # @rbs timeout: Numeric? -- Maximum wait time in milliseconds
  # @rbs return: Puppeteer::JSHandle -- Handle to evaluation result
  def wait_for_function: (String page_function, ?args: Array[untyped], ?polling: String | Numeric | nil, ?timeout: Numeric?) -> Puppeteer::JSHandle
end
